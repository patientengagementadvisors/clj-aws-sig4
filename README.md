# clj-aws-sig4
This simple project that has functions for creating the authorization header required for aws-sig4 http request. There are two example HTTP calls outlined here:

https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html

A GET and a PUT, these are implemented as tests, so we know the rather complex hashing works as intended.

This code barrows from the work done by:

https://github.com/sharetribe/aws-sig4

and continued by:

https://github.com/zarkone/aws-sig4

but this project does not attempt to provide any clj-http middleware, because there is a bug in clj-http that makes it impossible with HTTP calls that have a body.

You can of course use clj-http (I wouldn't leave home without it), you just need to add the aws-sig4 stuff to the calls beforehand.

# Rational
Most AWS services can be access by an SDK, so in the clojure space, that means using:

https://github.com/cognitect-labs/aws-api

But there are services where you still need to sign things yourself. I need this to access OpenSearch Serverless content, since this service requires aws-sig4 signing.
I have a bunch of existing code based on clj-http to access ElasticSearch that I want to re-use with OpenSearch. Which I can now, by simply signing my existing calls to elastic.

If you are trying to use OpenSearch with aws-sig4, OpenSearch publishes a Java SDK:

https://github.com/opensearch-project/opensearch-java

But it is 100% a _**Java**_ library, and all that that implies.

## How to use it
When composing an HTTP request that needs to be aws-sig4 signed, you need to do the following things.

1. Identify which headers you want to sign.
2. make sure those headers are in your request, plus add an ```Authorization``` header with a value generated by this project.

### Identify which headers you want to sign.
For non-body requests GET, DELETE, HEAD, etc, you need at least the following headers:
```http request
X-Amz-Date: 20230222T161412Z
Host: blablabla.us-east-1.aoss.amazonaws.com
```
For requests with bodies POST, PUT, PATCH you need to also include an  ```X-Amz-Content-Sha256``` header.
```http request
X-Amz-Date: 20230222T161412Z
Host: blablabla.us-east-1.aoss.amazonaws.com
X-Amz-Content-Sha256: c20d2a6a45cff1f6b6f25b7403411fa6f1d43d0df4a4e0b008d040bd60a83f27
```

You may include other headers in your request, but we need to identify which ones _are used in the signing._ 
You may elect to include additional headers, and some specific services _may_ require them. But the ones listed above are the baseline for all services.

note: The documentation by AWS says you can substitute X-Amz-Date for a Date header as a signed header. Also, the documentation implies there is a technique to not include Sha256 of the content, but I couldn't find a great way to test that.

When all is said and done, your header may look something like this:
```http request
X-Amz-Date: 20230222T035503Z
Host: blablabla.us-east-1.aoss.amazonaws.com
X-Amz-Content-Sha256: c20d2a6a45cff1f6b6f25b7403411fa6f1d43d0df4a4e0b008d040bd60a83f27
Authorization: AWS4-HMAC-SHA256 Credential=XXXXX/20230222/us-east-1/aoss/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=1e93f17efc5356fb33644a8ca43ff423c400f44e1f4ae18ae4a6fe3974c69837
Content-Type: application/json
Cache-Control: no-cache
Content-Length: 88
```

## Here is some sample code
This library assumes inputs to the create-authorization function are formatted correctly. Most things need to be lower case and url-encoded to work right. The AWS doc above spells it out. I added notes in the sample code below where formatting is important.
```clojure
(ns opensearch-example
  (:require [pea.aws.aws-sig4 :as sig4]
            [clojure.data.json :as json]
            [clj-http.client :as client])
  
  (:import (java.util UUID TimeZone Date)
           (java.text SimpleDateFormat)))


(def aws-full-format (SimpleDateFormat. "yyyyMMdd'T'HHmmss'Z'"))
(.setTimeZone aws-full-format (TimeZone/getTimeZone "GMT"))

; This is the stuff we actually care about
(def base-url "https://xxxxxxxxxxx.us-east-1.aoss.amazonaws.com")
(def index-name (.toString (UUID/randomUUID))) ;random for testing
(def body (json/write-str {"settings" {"number_of_shards" 1} "mappings" {"properties" {"field1" {"type" "text"}}}}))


; This is the stuff we need to sort out for signing
(def aws-key "AKIXXXXXXX")
(def aws-secret "sCDcsdgweg3434f4f34f4f/4444g4gg")
(def region "us-east-1")
(def service "aoss"); or "s3" or "es" or whatever.
(def date (Date.))
(def date-str (.format aws-full-format date)) ;I am sure there are nicer ways to format dates these days :)

; The keys need to be lower case here, but can be any case in the actual http call
(def headers-to-be-signed {"host" "xxxxxxxxxxx.us-east-1.aoss.amazonaws.com" ; No https protocol prefix. 
                           "x-amz-content-sha256" (sig4/hash-hex body) ; required if we have a body
                           "x-amz-date" date-str}) ; formatted like, "20130524T000000Z" I did not test if it needs to be GMT. But this one is.

(def sorted-keys (sort (keys headers-to-be-signed))) ;we need these sorted alphabetically
(def uri (str "/" index-name));This needs to be URIEncoded if it has weird chars in it. See the AWS doc linked above.
(def query-string "format=json&pretty=true");Both the keys and values in this list need to be URIEncoded. See the AWS doc linked above.

(def authorization (sig4/create-authorization "PUT" uri query-string aws-key aws-secret date-str region service sorted-keys headers-to-be-signed))

; This is the call to actually create the index.
(def all-headers (merge {"Authorization" authorization} headers-to-be-signed {"Other-Header" "You Might Need Like ->" "Cache-Control" "no-cache"}))
(def url (str base-url "/" index-name "?" query-string))
(client/put url {:body body :content-type :json :headers all-headers :throw-exceptions false})
;Note: the :content-type will add an unsigned header to the request, which is totally OK.
```
